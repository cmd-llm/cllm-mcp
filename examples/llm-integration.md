# LLM Integration Examples

This document shows how to integrate the MCP CLI with various LLM workflows.

## Example 1: Simple File Operations Prompt

### Traditional Approach (High Token Usage)

```
System Prompt: You have access to the following tools...
[Include full MCP tool definitions: ~2000 tokens]

- read_file(path: string): Read a file
  Schema: { type: "object", properties: { path: { type: "string", description: "..." }}}
- write_file(path: string, content: string): Write to a file
  Schema: { type: "object", properties: { path: ..., content: ... }}
- list_directory(path: string): List directory contents
  Schema: ...
[etc.]
```

**Token count**: ~2000-3000 tokens for tool definitions

### MCP CLI Approach (Minimal Token Usage)

```
System Prompt: You can perform file operations using these bash commands:

Read file:
  ./mcp-wrapper.sh filesystem call-tool read_file '{"path": "<path>"}'

Write file:
  ./mcp-wrapper.sh filesystem call-tool write_file '{"path": "<path>", "content": "<content>"}'

List directory:
  ./mcp-wrapper.sh filesystem call-tool list_directory '{"path": "<path>"}'

All commands return JSON. Extract data using jq.
```

**Token count**: ~100-150 tokens

**Savings**: ~95% reduction in token usage

## Example 2: GitHub Operations

### LLM Prompt

```
You can interact with GitHub using these commands:

List issues:
  ./mcp-wrapper.sh github call-tool list_issues '{"owner": "<owner>", "repo": "<repo>"}'

Create issue:
  ./mcp-wrapper.sh github call-tool create_issue '{
    "owner": "<owner>",
    "repo": "<repo>",
    "title": "<title>",
    "body": "<description>"
  }'

Get issue:
  ./mcp-wrapper.sh github call-tool get_issue '{
    "owner": "<owner>",
    "repo": "<repo>",
    "issue_number": <number>
  }'

Comment on issue:
  ./mcp-wrapper.sh github call-tool create_comment '{
    "owner": "<owner>",
    "repo": "<repo>",
    "issue_number": <number>,
    "body": "<comment>"
  }'

Remember to set GITHUB_TOKEN in your environment or mcp-config.json.
```

### Example Task Execution

**User**: "Create a GitHub issue in myrepo about the login bug"

**LLM Response**:

```bash
./mcp-wrapper.sh github call-tool create_issue '{
  "owner": "myusername",
  "repo": "myrepo",
  "title": "Login Bug",
  "body": "Users are experiencing issues logging in. Investigation needed."
}'
```

## Example 3: Multi-Step Workflow

### Task: "Read a config file and create a GitHub issue with its contents"

**LLM Reasoning**:

1. Read the config file
2. Extract relevant information
3. Create GitHub issue

**LLM Execution**:

```bash
# Step 1: Read config file
CONFIG=$(./mcp-wrapper.sh filesystem call-tool read_file '{"path": "/path/to/config.json"}')

# Step 2: Extract content (using jq)
CONTENT=$(echo "$CONFIG" | jq -r '.content[0].text')

# Step 3: Create issue with content
./mcp-wrapper.sh github call-tool create_issue "{
  \"owner\": \"myuser\",
  \"repo\": \"myrepo\",
  \"title\": \"Config Review\",
  \"body\": \"Current configuration:\\n\\n\`\`\`json\\n$CONTENT\\n\`\`\`\"
}"
```

## Example 4: Custom Tool Wrapper

For frequently used operations, create specialized wrappers:

### create-bug-report.sh

```bash
#!/bin/bash
# Create a bug report from a log file

LOG_FILE="$1"
REPO_OWNER="$2"
REPO_NAME="$3"

# Read error log
LOG_CONTENT=$(./mcp-wrapper.sh filesystem call-tool read_file "{\"path\": \"$LOG_FILE\"}" | jq -r '.content[0].text')

# Extract last 20 lines
RECENT_ERRORS=$(echo "$LOG_CONTENT" | tail -20)

# Create issue
./mcp-wrapper.sh github call-tool create_issue "{
  \"owner\": \"$REPO_OWNER\",
  \"repo\": \"$REPO_NAME\",
  \"title\": \"Automated Bug Report - $(date +%Y-%m-%d)\",
  \"body\": \"### Error Log\\n\\nRecent errors from $LOG_FILE:\\n\\n\`\`\`\\n$RECENT_ERRORS\\n\`\`\`\\n\\n*Automatically generated*\",
  \"labels\": [\"bug\", \"automated\"]
}"
```

### LLM Prompt

```
To create a bug report from logs, use:
  ./create-bug-report.sh <log_file> <owner> <repo>
```

**Result**: Even simpler for LLM, one command instead of multi-step reasoning.

## Example 5: Agentic Workflow

### Task: "Monitor a directory and report changes to GitHub"

**LLM Script Generation**:

```bash
#!/bin/bash
# monitor-and-report.sh
# Generated by LLM to monitor directory changes

WATCH_DIR="$1"
REPO_OWNER="$2"
REPO_NAME="$3"

# Get initial directory listing
INITIAL=$(./mcp-wrapper.sh filesystem call-tool list_directory "{\"path\": \"$WATCH_DIR\"}")

while true; do
    sleep 60  # Check every minute

    # Get current listing
    CURRENT=$(./mcp-wrapper.sh filesystem call-tool list_directory "{\"path\": \"$WATCH_DIR\"}")

    # Compare
    if [ "$INITIAL" != "$CURRENT" ]; then
        # Changes detected, create issue
        DIFF=$(diff <(echo "$INITIAL") <(echo "$CURRENT"))

        ./mcp-wrapper.sh github call-tool create_issue "{
          \"owner\": \"$REPO_OWNER\",
          \"repo\": \"$REPO_NAME\",
          \"title\": \"Directory Changes Detected\",
          \"body\": \"Changes in $WATCH_DIR:\\n\\n\`\`\`\\n$DIFF\\n\`\`\`\"
        }"

        INITIAL="$CURRENT"
    fi
done
```

## Example 6: Error Handling Pattern

### Robust LLM-Generated Script

```bash
#!/bin/bash
set -euo pipefail

# Function to call MCP tool with error handling
call_mcp_tool() {
    local server="$1"
    local tool="$2"
    local params="$3"

    local output
    local exit_code=0

    output=$(./mcp-wrapper.sh "$server" call-tool "$tool" "$params" 2>&1) || exit_code=$?

    if [ $exit_code -ne 0 ]; then
        echo "Error calling $tool: $output" >&2
        return 1
    fi

    echo "$output"
}

# Usage
if ! result=$(call_mcp_tool filesystem read_file '{"path": "/tmp/file.txt"}'); then
    echo "Failed to read file, using default content"
    result='{"content": [{"text": "default"}]}'
fi

content=$(echo "$result" | jq -r '.content[0].text')
echo "Content: $content"
```

## Example 7: Parallel Tool Calls

```bash
#!/bin/bash
# Call multiple MCP tools in parallel

# Read multiple files in parallel
./mcp-wrapper.sh filesystem call-tool read_file '{"path": "/tmp/file1.txt"}' > /tmp/result1.json &
PID1=$!

./mcp-wrapper.sh filesystem call-tool read_file '{"path": "/tmp/file2.txt"}' > /tmp/result2.json &
PID2=$!

./mcp-wrapper.sh filesystem call-tool read_file '{"path": "/tmp/file3.txt"}' > /tmp/result3.json &
PID3=$!

# Wait for all to complete
wait $PID1 $PID2 $PID3

# Process results
cat /tmp/result1.json /tmp/result2.json /tmp/result3.json | jq -s '.'
```

## Token Usage Comparison

### Scenario: File operations + GitHub + Database access

| Approach        | Tool Definitions | Instructions | Total Tokens |
| --------------- | ---------------- | ------------ | ------------ |
| Traditional MCP | 5,000            | 500          | **5,500**    |
| MCP CLI         | 0                | 300          | **300**      |
| **Savings**     | **100%**         | **-40%**     | **~95%**     |

## Best Practices for LLM Integration

1. **Keep commands simple**: One-liners are easier for LLMs to generate correctly
2. **Use environment variables**: For common parameters (repo name, base path, etc.)
3. **Provide examples**: Show the exact JSON format expected
4. **Error handling**: Always instruct LLM to handle errors gracefully
5. **Validation**: Have LLM validate JSON before passing to MCP CLI
6. **Logging**: Redirect stderr to log files for debugging

## Sample System Prompt Template

````
You are an AI assistant with access to MCP (Model Context Protocol) tools via bash scripts.

## Available MCP Servers

### Filesystem (./mcp-wrapper.sh filesystem)
- read_file: '{"path": "<path>"}'
- write_file: '{"path": "<path>", "content": "<content>"}'
- list_directory: '{"path": "<path>"}'

### GitHub (./mcp-wrapper.sh github)
- create_issue: '{"owner": "<owner>", "repo": "<repo>", "title": "<title>", "body": "<body>"}'
- get_issue: '{"owner": "<owner>", "repo": "<repo>", "issue_number": <num>}'
- create_comment: '{"owner": "<owner>", "repo": "<repo>", "issue_number": <num>, "body": "<comment>"}'

## Usage Guidelines
1. All commands return JSON responses
2. Extract data using `jq`: `| jq -r '.content[0].text'`
3. Handle errors: Check exit codes and stderr
4. Escape quotes in JSON: use \" inside single quotes

## Example
To read a file and create an issue:
```bash
CONTENT=$(./mcp-wrapper.sh filesystem call-tool read_file '{"path": "/tmp/file.txt"}' | jq -r '.content[0].text')
./mcp-wrapper.sh github call-tool create_issue "{\"owner\": \"user\", \"repo\": \"repo\", \"title\": \"Report\", \"body\": \"$CONTENT\"}"
````

Execute bash commands to accomplish user requests.

```

## Conclusion

The MCP CLI approach dramatically reduces token usage while maintaining full functionality. LLMs can focus on task logic rather than protocol details, resulting in:

- Faster response times (less tokens to process)
- Lower API costs
- Simpler prompts
- Better reliability (less complex tool calling)
- Easier debugging and testing
```
